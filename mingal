#!/usr/bin/perl

# mingal - Mini Gallery (quickly create nice index of images with thumbnails)
# Copyright (C) 2005-2007 Mikhael Goikhman
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Usage:
#   mingal --help          # show short description of all options
#   mingal .               # create thumbnails linked to jpegs in current dir
#   mingal ~/photos/*.gif  # generate index, thumbnails and full images
# Create subdir full/ to force creating full images (reduced from originals).

use 5.6.0;

use strict;
use warnings;

our $VERSION = '0.2.0';

use File::Basename;

my $current_dir = `pwd`; chomp($current_dir);
my $date_str = $current_dir =~ m!.*/(\d\d[\d-]+(?:[\d|x]+))!i ? ", $1" : "";
my $title ||= "Photos$date_str";

my %o = (
	mini_geometry  => '320x240',
	full_geometry  => '75%',
	mini_quality   => '80%',
	full_quality   => '87%',
	recreate_index => undef,
	columns        => 2,
	comment        => "reduced by $ENV{USER}",
	no_sort        => undef,
	no_item_pages  => undef,
	no_auto_orient => undef,
	backlink_text  => "Return",
	homelink_html  => 'Generated by @MinGal_LINK on @TIME(%Y-%m-%d %T)',
	title          => $title,
);

# parse options

while (@ARGV && $ARGV[0] =~ /^--(.*?)(?:=(.*))?$/) {
	shift;
	my ($option, $value) = ($1, $2);
	my $key = $option; $key =~ s/-/_/g;
	if ($option eq "help") {
		my $exe = $0; $exe =~ s!.*/!!;
		print "Usage $0 [OPTIONS] FILES|DIRS\n";
		foreach (sort keys %o) {
			my $option = $_; $option =~ s/_/-/g;
			my $value = $o{$_};
			$value = "false" unless defined $value;
			print "\t--$option ($value)\n"
		}
		print "\nExamples:\n",
			"\t$exe .               # create index, thumbnails for *.jpg, no full\n",
			"\t$exe ~/photos/*.gif  # create index, thumbnails and full images\n",
			"\t$exe --full-geometry 60% --no-sort --no-item-pages /cam/trip-[321]\n",
			"Create subdir full/ to force creating full images (reduced from originals).\n";
		exit(0);
	}
	if (exists $o{$key}) {
		$o{$key} = defined $o{$key} ? defined $value ? $value : shift : 1;
	} else {
		die "Unknown option --$option\n";
	}
}

if ($o{recreate_index}) {
	die "--recreate-index is not implemented yet\n";
}
die "Nothing to do, try --help\n" unless @ARGV;

my $create_full = -d "full" && $o{full_geometry} ne '100%';
my @filenames;

while (@ARGV) {
	my $filename = shift @ARGV;
	if (-d $filename) {
		opendir(DIR, $filename);
		my @filenames = grep {
			/\.jpg$/i and $_ = "$filename/$_"
		} readdir(DIR);
		closedir DIR;
		unshift @ARGV, @filenames;
		next;
	}
	-r $filename || die "Can't find readable $filename\n";
	my ($name, $path) = fileparse($filename);
	$create_full ||= 1 if $path && $path ne "./";
	push @filenames, [ $filename, $name, $path ];
}

# create index file

my $index_file = 'index.html';
my $first_line = "<html><head>";

if (-f $index_file && `head -1 $index_file` ne "$first_line\n") {
	print "Foreign $index_file already exists, will not overwrite it\n";
	exit 1;
}

print "Creating $index_file\n";

open INDEX, ">$index_file" || die "Can't write $index_file: $!\n";
print INDEX <<ENDSTR;
$first_line
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>$o{title}</title>
<style><!--
body { background: #d0f0f0; text-align: center; }
a { color: #087878; font: 80% "Lucida Grande", Verdana, Lucida, Helvetica, Arial, sans-serif; }
table { background: #f4f4f4; padding: 1em 2%; margin: 0% 5%; width: 90%; text-align: center; border: 1px solid #98c8c8; }
td { padding: 0.5em 0em; }
img { border: 1px solid #707070; }
--></style>
</head><body>
<h1>$o{title}</h1>
<table>
ENDSTR

mkdir("mini");
mkdir("full") if $create_full;
mkdir("item") unless $o{no_item_pages};

my $num_len = length(@filenames);
my $col = 0;
my @auto_orient_opt = $o{no_auto_orient} ? () : ('-auto-orient');

# process each image and update index

@filenames = sort { $a->[0] cmp $b->[0] } @filenames unless $o{no_sort};

sub create_item_page ($$$$) {
	my ($name, $i, $num, $link) = @_;
	$i++;  # start to count from 1
	my $file = sprintf("item/%0${num_len}d.html", $i);
	my $prev_file = $i <= 1 ? undef :
		sprintf("%0${num_len}d.html", $i - 1);
	my $next_file = $i >= $num ? undef :
		sprintf("%0${num_len}d.html", $i + 1);
	my $prev_tag = !$prev_file ? "<span>Start</span>" :
		qq(<a href="$prev_file">&lt;- $filenames[$i - 2]->[1]</a>);
	my $next_tag = !$next_file ? "<span>End</span>" :
		qq(<a href="$next_file">$filenames[$i + 0]->[1] -&gt;</a>);
	my $title = "$name (#$i from $num)";
	open ITEM, ">$file" || die "Can't write $file: $!\n";
	print ITEM <<ENDSTR;
<html><head>
<title>$title</title>
<style><!--
body { background: #f4f4f4; text-align: center; margin: 3px; }
a,span { color: #087878; font: 80% "Lucida Grande", Verdana, Lucida, Helvetica, Arial, sans-serif; }
a { color: #087878; text-decorations: none; }
a:hover { text-decorations: underline; }
span { color: #707070; }
table { margin: 0px; padding: 0px; width: 100%; text-align: center; }
hr { border: 0px; border-top: 1px solid #707070; margin: 3px 0px 10px 0px; }
img { border: 1px solid #707070; }
--></style>
</head><body>
<table><tr>
<td width="30%" align="left">$prev_tag</td>
<td width="40%" align="center"><a href="../">$title</a></td>
<td width="30%" align="right">$next_tag</td>
</tr></table>
<hr />
<img src="../$link">
<br>
</body></html>
ENDSTR
	close ITEM;
	return $file;
}

for my $i (0 .. @filenames - 1) {
	my ($filename, $name, $path) = @{$filenames[$i]};
	print INDEX "<tr>\n" if $col == 0;
	print "Processing $filename ... ";
	system(
		'convert', '-geometry', $o{full_geometry}, '-quality', $o{full_quality},
		'-comment', $o{comment}, @auto_orient_opt, $filename, "full/$name"
	) if $create_full;
	system(
		'convert', '-size', $o{mini_geometry}, '-resize', $o{mini_geometry},
		'-quality', $o{mini_quality}, '+profile', '*',
		'-comment', $o{comment}, @auto_orient_opt, $filename, "mini/$name"
	);
	my $image_name_tag = "";
	my $image_body_link = ($create_full ? "full/" : "") . $name;
	unless ($o{no_item_pages}) {
		$image_name_tag = qq(</a><a href="$image_body_link">);
		$image_body_link = create_item_page($name, $i, 0 + @filenames, $image_body_link);
	}
	print INDEX qq(\t<td><a href="$image_body_link"><img src="mini/$name" /><br />$image_name_tag$name</a></td>\n);
	$col = ($col + 1) % $o{columns};
	print INDEX "</tr>\n" if $col == 0;
	print "done\n";
}

if ($col > 0 && $col < $o{columns}) {
	for (; $col < $o{columns}; $col++) {
		print INDEX "\t<td></td>\n";
	}
	print INDEX "</tr>\n";
}

print INDEX "</table>\n";
print INDEX "<hr />\n" if $o{backlink_text} || $o{homelink_html};
print INDEX "<a href='../'>$o{backlink_text}</a><br>\n" if $o{backlink_text};
if ($o{homelink_html}) {
	chomp(my $time_str = `date '+%Y-%m-%d %T'`);
	my $html = $o{homelink_html};
	$html =~ s/\@TIME\((.*?)\)/chomp(my $time_str = `date '+$1'`); $time_str/ge;
	$html =~ s!\@MinGal_LINK!<a href="http://migo.n3.net/software/mingal/">MinGal</a>!g;
	print INDEX $html, "\n";
}
print INDEX "</body></html>\n";
